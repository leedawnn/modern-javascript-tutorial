## 엄격 모드

---

자바스크립트는 꽤 오랫동안 호환성 이슈 없이 발전해왔습니다. 기존의 기능을 변경하지 않으면서 새로운 기능이 추가되었죠.  
 하지만, 2009년 이후 새롭게 제정된 ECMAScript5(ES5)에서는 새로운 기능이 추가되고 기존 기능 중 일부가 변경되었습니다. 기존 기능을 변경하였기 때문에 하위 호환성 문제가 생길 수 있겠죠? 그래서 변경사항 대부분은 ES5의 기본 모드에선 활성화되지 않도록 설계되었습니다. 대신 use strict라는 특별한 지시자를 사용해 **엄격 모드(strict mode)** 를 활성화 했을 때만 이 변경사항이 활성화되게 해놓았습니다.  
<br />

### use strict

```javascript
"use strict";

// 이 코드는 모던한 방식으로 실행됩니다.
...
```
<br />

⚠️ **"use strict"는 반드시 최상단에 위치시키세요.**  
   그렇지 않으면 엄격 모드가 활성화되지 않을 수도 있습니다. 그러나 스크립트 최상단이 아닌 함수 본문 맨 앞에 올 수도 있다는 점을 알아두시기 바랍니다. 이렇게 하면 오직 해당 함수만 엄격 모드로 실행됩니다. 엄격 모드는 대개 스크립트 전체에 적용하지만 말이죠.
<br />

⚠️ **use strict를 취소할 방법은 없습니다.**
자바스크립트 엔진을 이전 방식으로 되돌리는 "no use strict"같은 지시자는 존재하지 않습니다.  
일단 엄격 모드가 적용되면 돌이킬 방법은 없습니다.
<br />
<br />

### 'use strict’를 꼭 사용해야 하나요

"당연히 사용해야 하는 거 아니야?"라는 생각이 드시겠지만, 꼭 그렇지만은 않습니다.  

모던 자바스크립트는 '클래스’와 '모듈’이라 불리는 진일보한 구조를 제공합니다. 이 둘을 사용하면 use strict가 자동으로 적용되죠. 따라서 이 둘을 사용하고 있다면 스크립트에 "use strict"를 붙일 필요가 없습니다.  

결론은 코드를 클래스와 모듈을 사용해 구성한다면 "use strict"를 생략해도 됩니다.
<br />
<br />

## 변수와 상수
---  

### 변수  

변수(variable)는 데이터를 저장할 때 쓰이는 ‘이름이 붙은 저장소’ 입니다. 온라인 쇼핑몰 애플리케이션을 구축하는 경우 상품이나 방문객 등의 정보를 저장할 때 변수를 사용하죠.  

한 줄에 여러 변수를 선언하는 것도 가능합니다.

```javascript
let user = 'leedawn', age = 27, message = 'Hello';
```

<br />

❣️ **let 대신 var**  

만들어진 지 오래된 스크립트에서 let 대신 var라는 키워드를 발견하는 경우가 있습니다. var는 let과 거의 동일하게 동작합니다. var도 let처럼 변수를 선언하는 데 쓰이죠. 다만 var는 ‘오래된’ 방식입니다.

```javascript
var message = "안녕하세요.";
alert(message); // 안녕하세요.
```

하지만 var는 초기 자바스크립트 구현 방식 때문에 let과 const로 선언한 변수와는 다른 방식으로 동작합니다. 근래엔 var를 쓰지 않아서 이를 만나는 건 흔치 않은 일이지만, var는 오래된 스크립트에서 당신을 기다리고 있는 괴물 같은 존재입니다.

구식 스크립트를 다룰 계획이 없는 개발자라면 이 챕터를 건너뛰거나 학습을 미루려고 할 겁니다.

하지만 그랬다간 이 괴물에게 물릴 수 있습니다. 특히 var를 사용하는 오래된 스크립트를 let로 바꿀 때 var에 대해 제대로 알아두어야 합니다. 그렇지 않으면 예상치 못한 에러를 만날 수 있습니다.  
<br />

### 'var’는 블록 스코프가 없습니다.
var로 선언한 변수의 스코프는 함수 스코프이거나 전역 스코프입니다. 블록 기준으로 스코프가 생기지 않기 때문에 블록 밖에서 접근 가능합니다.

```javascript
if (true) {
  var test = true; // 'let' 대신 'var'를 사용했습니다.
}

alert(test); // true(if 문이 끝났어도 변수에 여전히 접근할 수 있음)
```  

코드 블록이 함수 안에 있다면, var는 함수 레벨 변수가 됩니다.  

```javascript
function sayHi() {
  if (true) {
    var phrase = "Hello";
  }

  alert(phrase); // 제대로 출력됩니다.
}

sayHi();
alert(phrase); // Error: phrase is not defined
```

위에서 살펴본 바와 같이, var는 if, for 등의 코드 블록을 관통합니다. 아주 오래전의 자바스크립트에선 블록 수준 렉시컬 환경이 만들어 지지 않았기 때문입니다. var는 구식 자바스크립트의 잔재이죠.  
<br />

### 'var'은 재선언을 허용합니다.  

동일한 범위에서 let을 사용하여 동일한 변수를 두 번 선언하면 오류가 납니다.

```javascript
let user;
let user; // SyntaxError: 'user' has already been declared
```  

그러나, var를 사용하면 여러 번 변수를 다시 선언할 수 있습니다. 이미 선언된 변수와 함께 var를 사용하면 무시됩니다.

```javascript
var user = "Pete";

var user = "John"; // this "var" does nothing (already declared)
// ...it doesn't trigger an error

alert(user); // John
```

<br />

### 변수 명명 규칙

자바스크립트에선 변수 명명 시 두 가지 제약 사항이 있습니다.

1. 변수명에는 오직 문자와 숫자, 그리고 기호 $와 _만 들어갈 수 있습니다.
2. 첫 글자는 숫자가 될 수 없습니다.  
<br />

### 상수(constant)

변화하지 않는 변수를 선언할 땐, let 대신 const를 사용합니다. 상수는 재할당할 수 없으므로 상수를 변경하려고 하면 에러가 발생합니다.

### 대문자 상수

```javascript
const COLOR_RED = "#F00";
const COLOR_GREEN = "#0F0";
const COLOR_BLUE = "#00F";
const COLOR_ORANGE = "#FF7F00";

// 색상을 고르고 싶을 때 별칭을 사용할 수 있게 되었습니다.
let color = COLOR_ORANGE;
alert(color); // #FF7F00
```

대문자로 상수를 만들어 사용하면 다음과 같은 장점이 있습니다.

- COLOR_ORANGE는 "#FF7F00"보다 기억하기가 훨씬 쉽습니다.
- COLOR_ORANGE를 사용하면 "#FF7F00"를 사용하는 것보다 오타를 낼 확률이 낮습니다.
- COLOR_ORANGE가 #FF7F00보다 훨씬 유의미하므로, 코드 가독성이 증가합니다.

그렇다면 언제 일반적인 방식으로 상수를 명명하고, 언제 대문자를 사용해서 명명해야 하는 걸까요? 결론적으로, **대문자 상수는 ‘하드 코딩한’ 값의 별칭을 만들 때 사용하면 됩니다.**  
<br />

## 논리 연산자

---

### 형 변환 법칙

숫자 0, 빈 문자열"", null, undefined, NaN은 불린형으로 변환 시 모두 false가 됩니다. 이런 값들은 ‘falsy(거짓 같은)’ 값이라고 부릅니다.  

이 외의 값은 불린형으로 변환시 true가 되므로 ‘truthy(참 같은)’ 값이라고 부릅니다.  
<br />

### 조건부 연산자 ‘?’

조건에 따라 다른 값을 변수에 할당해줘야 할 때가 있습니다. 조건부 연산자는 물음표?로 표시합니다. 피연산자가 세 개이기 때문에 조건부 연산자를 '삼항(ternary) 연산자’라고 부르는 사람도 있습니다. 참고로, 자바스크립트에서 피연산자가 3개나 받는 연산자는 조건부 연산자가 유일합니다.

```javascript
let result = condition ? value1 : value2;
```

평가 대상인 condition이 truthy라면 value1이, 그렇지 않으면 value2가 반환됩니다.  
<br />

### 논리 연산자
자바스크립트엔 세 종류의 논리 연산자 ||(OR), &&(AND), !(NOT)이 있습니다.

연산자에 '논리’라는 수식어가 붙긴 하지만 논리 연산자는 피연산자로 불린형뿐만 아니라 모든 타입의 값을 받을 수 있습니다. 연산 결과 역시 모든 타입이 될 수 있습니다.  
<br />

### 첫 번째 truthy를 찾는 OR 연산자 ‘||’

```javascript
let firstName = "";
let lastName = "";
let nickName = "바이올렛";

alert( firstName || lastName || nickName || "익명"); // 바이올렛
```

OR "||" 연산자를 여러 개 체이닝(chaining) 하면 첫 번째 truthy를 반환합니다. 피연산자에 truthy가 하나도 없다면(모든 피연산자가 false로 평가되는 경우) 마지막 피연산자를 반환합니다.  
<br />

### 첫 번째 falsy를 찾는 AND 연산자 ‘&&’

```javascript
// 첫 번째 피연산자가 truthy이면,
// AND는 두 번째 피연산자를 반환합니다.
alert( 1 && 0 ); // 0
alert( 1 && 5 ); // 5

// 첫 번째 피연산자가 falsy이면,
// AND는 첫 번째 피연산자를 반환하고, 두 번째 피연산자는 무시합니다.
alert( null && 5 ); // null
alert( 0 && "아무거나 와도 상관없습니다." ); // 0
```

AND 연산자는 첫 번째 falsy를 반환합니다. 피연산자에 falsy가 없다면 마지막 값을 반환합니다.  
<br />

### 연산자의 우선순위

NOT > && > || 순으로 실행됩니다.  
<br />

## null 병합 연산자 '??'

---
⚠️ 스펙에 추가된 지 얼마 안 된 문법입니다. 구식 브라우저는 폴리필이 필요합니다.  

null 병합 연산자(nullish coalescing operator) ??를 사용하면 짧은 문법으로 여러 피연산자 중 그 값이 ‘확정되어있는’ 변수를 찾을 수 있습니다.  

a ?? b의 평가 결과는 다음과 같습니다.  
- a가 null도 아니고 undefined도 아니면 a
- 그 외의 경우는 b  

null 병합 연산자 ??없이 x = a ?? b와 동일한 동작을 하는 코드를 작성하면 다음과 같습니다.

```javascript
x = (a !== null && a !== undefined) ? a : b;
```

또 다른 예시를 살펴보겠습니다. firstName, lastName, nickName이란 변수에 사용자 이름이나 별명을 저장하는데, 사용자가 아무런 정보도 입력하지 않는 케이스도 허용한다고 해보겠습니다.

화면엔 세 변수 중 실제 값이 있는 변수의 값을 출력하는데, 세 변수 모두 값이 없다면 '익명의 사용자’가 출력되도록 해보죠.

이럴 때 null 병합 연산자 ??를 사용하면 값이 정해진 변수를 간편하게 찾아낼 수 있습니다.

```javascript
let firstName = null;
let lastName = null;
let nickName = "바이올렛";

// null이나 undefined가 아닌 첫 번째 피연산자
alert(firstName ?? lastName ?? nickName ?? "익명의 사용자"); // 바이올렛
```  

### '??'와 '||'의 차이

null 병합 연산자는 OR 연산자 ||와 상당히 유사해 보입니다. 실제로 위 예시에서 ??를 ||로 바꿔도 그 결과는 동일하기까지 하죠. 

그런데 두 연산자 사이에는 중요한 차이점이 있습니다.

- ||는 첫 번째 truthy 값을 반환합니다.
- ??는 첫 번째 정의된(defined) 값을 반환합니다.

null과 undefined, 숫자 0을 구분 지어 다뤄야 할 때 이 차이점은 매우 중요한 역할을 합니다.  

```javascript
let height = 0;

alert(height || 100); // 100
alert(height ?? 100); // 0
```

height || 100은 height에 0을 할당했지만 0을 falsy 한 값으로 취급했기 때문에 null이나 undefined를 할당한 것과 동일하게 처리합니다. 따라서 height || 100의 평가 결과는 100입니다.

반면 height ?? 100의 평가 결과는 height가 정확하게 null이나 undefined일 경우에만 100이 됩니다. 예시에선 height에 0이라는 값을 할당했기 때문에 얼럿창엔 0이 출력됩니다.

이런 특징 때문에 높이처럼 0이 할당될 수 있는 변수를 사용해 기능을 개발할 땐 ||보다 ??가 적합합니다.  
<br />

### 연산자 우선순위

??는 =와 ? 보다는 먼저, 대부분의 연산자보다는 나중에 평가됩니다. 그렇기 때문에 복잡한 표현식 안에서 ??를 사용해 값을 하나 선택할 땐 괄호를 추가하는 게 좋습니다.  
??엔 자바스크립트 언어에서 규정한 또 다른 제약사항이 있습니다.
**안정성 관련 이슈 때문에 ??는 &&나 ||와 함께 사용하지 못합니다.**  

아래 예시를 실행하면 문법 에러가 발생합니다.

```javascript
let x = 1 && 2 ?? 3; // SyntaxError: Unexpected token '??'
```

이 제약에 대해선 아직 논쟁이 많긴 하지만 사람들이 ||를 ??로 바꾸기 시작하면서 만드는 실수를 방지하고자 명세서에 제약이 추가된 상황입니다.

제약을 피하려면 괄호를 사용해주세요.

```javascript
let x = (1 && 2) ?? 3; // 제대로 동작합니다.

alert(x); // 2
```
  
<br />

### break/continue와 레이블

여러 개의 중첩 반복문을 한 번에 빠져나와야 하는 경우가 종종 생기곤 합니다.

i와 j를 반복하면서 프롬프트 창에 (0,0)부터 (2,2)까지를 구성하는 좌표 (i, j)를 입력하게 해주는 예시를 살펴봅시다.

```javascript
for (let i = 0; i < 3; i++) {
  for (let j = 0; j < 3; j++) {
    let input = prompt(`(${i},${j})의 값`, '');
    // 여기서 멈춰서 아래쪽의 `완료!`가 출력되게 하려면 어떻게 해야 할까요?
  }
}

alert('완료!');
```

사용자가 Cancel 버튼을 눌렀을 때 반복문을 중단시킬 방법이 필요합니다.

input 아래에 평범한 break 지시자를 사용하면 안쪽에 있는 반복문만 빠져나올 수 있습니다. 이것만으론 충분하지 않습니다(중첩 반복문을 포함한 반복문 두 개 모두를 빠져나와야 하기 때문이죠.) 이럴 때 레이블을 사용할 수 있습니다.

**레이블(label)** 은 반복문 앞에 콜론과 함께 쓰이는 식별자입니다.

```javascript
labelName: for (...) {
  ...
}
```

반복문 안에서 break <labelName>문을 사용하면 레이블에 해당하는 반복문을 빠져나올 수 있습니다.

```javascript
outer: for (let i = 0; i < 3; i++) {

  for (let j = 0; j < 3; j++) {

    let input = prompt(`(${i},${j})의 값`, '');

    // 사용자가 아무것도 입력하지 않거나 Cancel 버튼을 누르면 두 반복문 모두를 빠져나옵니다.
    if (!input) break outer; // (*)

    // 입력받은 값을 가지고 무언가를 함
  }
}
alert('완료!');
```

위 예시에서 break outer는 outer라는 레이블이 붙은 반복문을 찾고, 해당 반복문을 빠져나오게 해줍니다. 따라서 제어 흐름이 (*)에서 alert('완료!')로 바로 바뀝니다.  

레이블을 별도의 줄에 써주는 것도 가능합니다.
